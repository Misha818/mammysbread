{% extends "base.html" %}

{% block title %}
    {{ _('Send Email') }}
{% endblock %}

{% block head %}

<link rel="stylesheet" href="{{ url_for('static', filename='quill.snow.css') }}">
<link href="https://fonts.googleapis.com/css?family=Roboto|Montserrat|Lato|Oswald|Playfair+Display|Raleway" rel="stylesheet">
<style>
.ql-snow .ql-picker.ql-font .ql-picker-label::before, .ql-snow .ql-picker.ql-font .ql-picker-item::before {
    content: 'Roboto';
}

.ql-snow .ql-picker.ql-font {
    width: 120px;
}

#response {
    width: 90%;
    margin: 50px auto 15px auto;
}

</style>

{% endblock %}

{% block content %}

{{ sideBar | safe }}



<div class="container toRight" id="tableDaddy" style="width: 70%;">
    {% set email = '' %}
    {% set emailID = '' %}

    {% if filterContent | length > 0 %}
        {% if filterContent.email %}
            {% set email = filterContent.email %}
        {% endif %}

        {% if filterContent.emailID and filterContent.emailID is digit %}
            {% set emailID = filterContent.emailID | int %}
        {% endif %}
    {% endif %}
<div id="response"></div>
<div class="mb-3 transfer-funds">

    {% if result.length > 0 %}
        <select id="from" class="styled-select" style="margin-bottom: 10px;">
            <option value="">{{ _('Choose sender email address') }}</option>
            {% for val in result.data %}                
                {% set selected = '' %}
                {% if result.length == 1 %}
                    {% set selected = 'selected' %}
                {% elif emailID != '' %}
                    {% if emailID == val['ID'] %}
                        {% set selected = 'selected' %}
                    {% endif %}                
                {% endif %}
                <option value="{{ val['ID'] }}" {{ selected }}>
                    {{ val['email'] }}
                </option>
            {% endfor %}
        </select>
        
    {% endif %}

    <input type="email" id="to" value="{{ email }}" placeholder="{{ _('Enter recipient email address') }}"  style="width: 100%; height: 45px;">
    <input type="text" id="subject" placeholder="{{ _('Subject') }}"  style="width: 100%; height: 45px;">

    <!-- Quill.js editor container -->
    <div id="editor" ></div>
</div>


</div>

<div class="containerH">

    <div class="pcButtonS" id="submit">{{ _('Submit')}}</div>
    <div class="pcButtonS hidden" id="saving">{{ _('Saving...')}}</div>
</div>

<script src="{{ url_for('static', filename='JS/1-3-6-quill.js') }}"></script>
<script>

document.addEventListener('DOMContentLoaded', function() {
    

    function imageHandler() {
            const input = document.createElement('input');
            input.setAttribute('type', 'file');
            input.setAttribute('accept', 'image/*');
            input.click();

            input.onchange = function () {
                const file = input.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {
                        const base64String = e.target.result;
                        const base64WithFileName = 'data:' + file.type + ';filename=' + file.name + ';base64,' + base64String.split(',')[1];
                        insertBase64Image(base64WithFileName);
                    };
                    reader.readAsDataURL(file);
                }
            };
        }

        function insertBase64Image(base64String) {
            const range = quill.getSelection();
            quill.insertEmbed(range.index, 'image', base64String);
        }









        

        // 1. Import the Font format from Quill
const Font = Quill.import('formats/font');

// 2. Create an array of font keys
//    Use simple, lowercase strings (no spaces) to avoid Quill confusion
//    For multi-word fonts like "Playfair Display", pick a single string, e.g. 'playfair-display'
const fonts = [
  'roboto',
  'montserrat',
  'lato',
  'oswald',
  'playfair-display',
  'raleway'
];

// 3. Whitelist the fonts and register them
Font.whitelist = fonts;
Quill.register(Font, true);

       
    // Initialize Quill.js editor
    const toolbarOptions = [
        ['bold', 'italic', 'underline', 'strike'],
        // ['blockquote', 'code-block'],
        // ['link', 'image', 'video', 'formula'],
        ['link'],
        // [{ 'header': 1 }, { 'header': 2 }],
        [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'list': 'check' }],
        // [{ 'script': 'sub' }, { 'script': 'super' }],
        [{ 'indent': '-1' }, { 'indent': '+1' }],
        [{ 'direction': 'rtl' }],
        [{ 'size': ['small', false, 'large', 'huge'] }],
        [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
        [{ 'color': [] }, { 'background': [] }],
        // [{ 'font': ['roboto', 'montserrat', 'lato', 'oswald', 'playfair', 'raleway'] }],
        [{ 'font': fonts }],
        [{ 'align': [] }]
    ];



const quill = new Quill('#editor', {
  theme: 'snow',
  placeholder: "{{ _('Additional notes') }}",
  modules: {
    toolbar: {
      container: toolbarOptions, 
      handlers: {
        image: imageHandler
      }
    }
  }
});



// Select the target element
const fontLabel = document.querySelector('.ql-font .ql-picker-label');

if (fontLabel) {
  // Create a MutationObserver instance to watch for attribute changes
  const observer = new MutationObserver((mutationsList) => {
    mutationsList.forEach((mutation) => {
      if (mutation.type === 'attributes' && mutation.attributeName === 'data-value') {
        const newValue = fontLabel.getAttribute('data-value');
        // console.log('New data-value:', newValue);
        updateCSSContent(newValue);
      }
    });
  });

  // Start observing the target element for attribute changes to 'data-value'
  observer.observe(fontLabel, { attributes: true, attributeFilter: ['data-value'] });
} else {
  console.warn('Element .ql-font .ql-picker-label not found');
}


// Function to update (or create) a style element with new CSS rule
function updateCSSContent(newValue) {
  newValue = formatFontName(newValue); 
  // Try to find an existing style element we can update
  let styleElem = document.getElementById('dynamic-font-style');
  if (!styleElem) {
    styleElem = document.createElement('style');
    styleElem.id = 'dynamic-font-style';
    document.head.appendChild(styleElem);
  }
  // Update the CSS rule. The content property must be quoted.
  styleElem.innerHTML = `
    .ql-snow .ql-picker.ql-font .ql-picker-label::before,
    .ql-snow .ql-picker.ql-font .ql-picker-item::before {
      content: '${newValue}';
      font-family: '${newValue}';
    }
  `;
}


function formatFontName(fontKey) {
  return fontKey
    .split('-') // split by dash
    .map(word => word.charAt(0).toUpperCase() + word.slice(1)) // capitalize each part
    .join(' '); // rejoin with space
}





        let csrfToken = "{{ csrf_token() }}";
        document.getElementById('submit').onclick = function() {
            event.preventDefault(); // Prevent form submission
            clickedBotton = document.getElementById('submit');
            let loader = myLoader('#fff');    
            
            clickedBotton.textContent = '';
            clickedBotton.appendChild(loader);

            let gearElement = document.getElementById('gear');
            if (!gearElement) {
            return;
            } 
            rotate(gearElement);

            let response = document.querySelector("#response");
            response.innerHTML = "";
            response.style.display = 'none';
            document.getElementById("from").style.borderColor = "black";
            document.getElementById("to").style.borderColor = "black";
            document.getElementById("subject").style.borderColor = "black";

            let answer;

            let from = document.getElementById("from").value;
            if (!from) {
                response.innerHTML = "{{ _('Please specify sender email address!') }}";
                response.style.display = 'flex';
                document.getElementById("from").style.borderColor = "red";

                gearElement.remove();
                clickedBotton.textContent = `{{ _('Submit') }}`;
                return;
            }
            
            let to = document.getElementById("to").value;
            if (!to) {
                response.innerHTML = "{{ _('Please specify recipient email address!') }}";
                response.style.display = 'flex';
                document.getElementById("to").style.borderColor = "red";

                gearElement.remove();
                clickedBotton.textContent = `{{ _('Submit') }}`;
                return;
            }
            
            let subject = document.getElementById("subject").value;
            if (!subject) {
                response.innerHTML = "{{ _('Please specify subject!') }}";
                response.style.display = 'flex';
                document.getElementById("subject").style.borderColor = "red";

                gearElement.remove();
                clickedBotton.textContent = `{{ _('Submit') }}`;
                return;
            }

            
            let content = quill.root.innerHTML;
            const delta = quill.getContents();
            const hasContent = delta.ops.some(op => {
                return op.insert && typeof op.insert === 'string' && op.insert.trim() !== '';
            });
                
            let formData = new FormData();

            formData.append('from', from)     
            formData.append('to', to)     
            formData.append('subject', subject)     
            formData.append('content', content)     

            // Create a new XMLHttpRequest object
            let xhr = new XMLHttpRequest();
            
            // Configure the request
            xhr.open('POST', '/send-email');
            xhr.setRequestHeader('X-CSRFToken', csrfToken);

            // Define what happens on successful data submission
            xhr.onload = function () {
                if (xhr.status === 200) {
                    gearElement.remove();
                    clickedBotton.textContent = `{{ _('Submit') }}`;
                    const response = JSON.parse(xhr.responseText);
                    if (response.status === '1') {
                        alert(response.answer)
                        
                    }
                    
                    if (response.status === '0') {
                        document.querySelector("#response").textContent = response.answer;
                        document.querySelector("#response").style.display = 'flex';
                        return;
                    } 
                    
                    
                } else {
                    gearElement.remove();
                    clickedBotton.textContent = `{{ _('Submit') }}`;
                    console.error('Request failed with status: ' + xhr.status);
                }
            };

            // Define what happens in case of error
            xhr.onerror = function () {
                console.error('Request failed.');
            };

            // Send the request with the JSON data
            xhr.send(formData);
        };


    function rotate(gearElement) {
        let angle = 0;
        setInterval(() => {
            angle = (angle + 5) % 360; 
            gearElement.style.transform = `rotate(${angle}deg)`;
        }, 50); 
    
    }

    function myLoader(color) {
        if (color === undefined) {
          color = 'crimson'
        }
        let loader = document.createElement('div'); // Create a div element for the loader
          loader.id = 'gear';
          loader.style.color = color;
          loader.style.fontSize = '20px';
          loader.style.display = 'inline-block';
          loader.textContent = 'âš™';
          return loader;
    }
});

    </script>

{% endblock %}
